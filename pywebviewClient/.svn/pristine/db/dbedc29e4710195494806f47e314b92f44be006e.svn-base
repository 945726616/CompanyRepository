<html>
<!-- 发布到dcm服务器上用于测试入口服务器index文件 -->
<head>
  <meta http-equiv="content-type" content="text/html" charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<script type="text/javascript">
		var m_hostname  = 'test.vimtag.com'// 全局品牌名
	    var contain_https // https域名在返回值中固定位置获取
	    var proto // 协议
	    var host // 域名
	    var serverArr = [] // 获取所有信令服务器地址数组
	    var httpsTest // https协议测试结果
	    var cmipcgwGetData // cmipcgw获取的全部数据

	    // 加载完成后执行函数
	    function start() {
	    	var s, temp, tp = null, request, ran, appid, urls
	    	// 随机数 用于请求handle
	    	ran = Math.floor(Math.random() * 10000)
	    	appid = 'vimtag.com'
	    	// 仅请求信令服务器地址不需要其他参数暂定使用简单参数方法
      		request = "/cmipcgw/cmipcgw_get_req.js?handle=" + ran + "&dclient=1&dclient_param__x_countz_=1&dclient_param=1&dclient_param_name=appid&dclient_param_value=" + appid
      		// http协议入口服务器地址遍历
          	urls = ["52.8.41.82:7080", "209.133.212.170:7080", "149.202.201.87:7080", "119.23.57.95:7080"]
          	function check_link(index) {
	            temp = urls[index]
	            s = document.createElement("script")
	            s.setAttribute("type", "text/javascript")
	            s.setAttribute("src", "http://" + temp + request)
	            s.onerror = function () {
	              if ((index + 1) >= urls.length) {
	                return false
	              } else {
	                check_link(index + 1)
	              }
	            }
	            document.getElementsByTagName('head').item(0).appendChild(s)
          	}
          	check_link(0)
	    }

	    // 请求后返回结果处理函数
		function message(obj) {
		    if (obj && obj.type === "cmipcgw_get_ack") { // 获取信令服务器接口回调截取
		        if (obj && obj.data && obj.data.result == "" && obj.data.server.signal && obj.data.server.signal[0]) { // 筛选正确返回值的接口内容
		          	obj.data.server.signal[0] = obj.data.server.signal[0].substring(0, obj.data.server.signal[0].lastIndexOf("/")) // 去除第一条返回数据中的/ccm 原第一条数据为'http://45.113.201.4:7080/ccm'
		          	serverArr = obj.data.server.signal // 将信令服务器地址全部存储
		          	cmipcgwGetData = obj.data // cmipcgw接口获取的全部数据信息
			        function get_pic() { // 使用测试图片测试链接通断
			            var o = new Image()
			            o.src = "https://" + m_hostname + "/test_img.png?" + (Math.floor(Math.random()*10000)) // 请求固定地址的测试图片
			            o.onload = function () { // 成功加载切换地址为https协议
			              httpsTest = true
			              // load_https()
			            }
			            o.onerror = function () { // 保持当前http协议
			              // contain_https = undefined
			              httpsTest = false
			              // load_iframe()
			            }
			            load_iframe()
			        }
			        get_pic()
			        function load_iframe(data) { // 渲染下一层iframe地址(固定dcm地址, 加载版本js文件并且渲染最终要展示的页面)
			            // 新增https地址头返回异常的简单处理, 对于未正常返回https的情况进行http地址的重新加载
			            if ("https:" === window.location.protocol && !serverArr[2]) { // 请求的方式为https, 但返回的信令服务器地址不包含https
			              var changeHttpsToHttp = window.location.href.replace("https:", "http:")
			              window.location.href = changeHttpsToHttp
			              return
			            }
			            // 调用的为version_control的正式版地址
			            document.body.innerHTML = "<iframe id='main_ifr' onload='load()' src='" + (("https:" === window.location.protocol) ? serverArr[2] : serverArr[0]) + "/dcm/static/version_control/index.htm' style='display:none'></iframe>"
			        }
		        }
		    }
	    }

	    // iframe加载完成后调用函数
	    function load() {
		    console.log(serverArr, 'serverArr')
		    console.log(m_hostname, 'm_hostname')
		    console.log(httpsTest, 'httpsTest')
		    // 传递的参数signalServer: 信令服务器地址数组 host: 域名 browserHref: 当前浏览器URL httpsTest: https测试结果True/False, cmipcgwGetData: cmipcgw获取的全部数据
		    browserHref = 'http://test.vimtag.com'
		    document.getElementById('main_ifr').contentWindow.postMessage({
		        signalServer: serverArr,
		        host: m_hostname,
		        httpsTest: httpsTest,
		        browserHref: browserHref,
		        cmipcgwGetData: cmipcgwGetData,
		    }, '*')
	    }

	    // 监听函数等待子页面返回的数据（从中分离加载页面的地址并执行跳转）
	    window.addEventListener('message', function(e) { // 从子页面中接收需要修改的title值,并修改title
	        // console.log('get childPage postMessage change the browser title', e.data)
	        // console.log('e.data.sendEvalFunc', e.data.sendEvalFunc)
	        console.log(e.data.loadUrl, 'loadUrl')
	        document.title = e.data.pageTitle
	        eval(e.data.sendEvalFunc)
	        if (window.pywebview) {
	        	console.log('判断为客户端')
				window.pywebview.api.reloadUrl(e.data.loadUrl)
	        } else {
	        	// 确定pywebview加载完成并从中分离出加载的地址 将地址传递给客户端重新加载
		        window.addEventListener('pywebviewready', function() {
					console.log('判断为客户端')
					window.pywebview.api.reloadUrl(e.data.loadUrl)
				})
	        }
	        
    	}, false)
	</script>
	<title></title>
</head>
<body onload="start()">
</body>
</html>